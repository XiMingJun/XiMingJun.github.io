[{"title":"开发常用工具集合","date":"2017-05-18T06:49:00.000Z","path":"2017/05/18/开发常用工具/","text":"开发常用工具集合 svn工具： CornerStone iOS安装包上传iap: Application Loader 屏幕录制工具：licecap 前端编辑器：sublime,Webstorm iOS 视图层次查看器：Reveal 思维导图： xmind 矢量做图工具：sketch 密码管理：1Password 图片自动标注：标你妹,蓝湖(目前不支持psd文件自动标注) 图片标注工具 ：Mark Man 文件对比工具：DiffMerge 颜色测色值工具：Sip 原型图工具：Axure 一键生成iOS 各种图片尺寸icon: Asset Catalog Creator(只需一张1024*1024) 笔记工具： 印象笔记","tags":[{"name":"iOS 开发工具","slug":"iOS-开发工具","permalink":"http://yoursite.com/tags/iOS-开发工具/"}]},{"title":"使用Xcode的Targets来管理开发和生产版本的构建.","date":"2017-02-04T07:40:56.000Z","path":"2017/02/04/使用Xcode的Targets来管理开发和生产版本的构建/","text":"技术总是需要在不断地学习，实践中获得进步，最近看到一篇文章挺好的，拿出来跟大家分享一下。 链接在这里 1.应用前生产和开发版本的管理。 生产和开发版本的区别 链接的环境不同。 开发版本的日志输出，生产版本不需要。 为了便于测试而对开发版本的的相应设置进行修改，生产版本需要改过来（例如某些宏定义的设置）。 对于以上问题，虽然有些可以通过区分debug和release版本进行区分，但是更多的还是要通过代码的修改来完成。我之前一直的做法就是在工程中这些不同的地方添加//TODO:注释，例如，然后需要做的就是测试完，打包上线前需要遍历项目中的TODO注释列表，挨个修改代码，切换成正式的版本。（万一有漏掉的，就等着老板屌你吧！） 很不幸，我之前一直都是这么做的，知道我看到上面的文章，原来可以如此简单的解决如此繁琐而不安全的问题，真是有种发现新大陆的感觉。 下面看看高大上的做法，瞬间觉得逼格满满。 2.应用后，使用Xcode的Targets来管理生产和开发版本。 相关的设置，在上边提到的文章中都有详细步骤，这里不再赘述。 这里总结一下需要注意的地方： 开发和正式版本bundleID 不同，最好分别制作证书，不同的Target设置不同证书。 添加文件时，两个Targets都要选，以保证代码同步，其他设置同理。 两者桌面icon最好区别一下，以免混淆。 最重要的一点：提交打包的时候不要选错Target!!!。 自此测试人员和开发人员可以同时安装两个版本的app,再也不会出现一会要测试环境，一会儿要正式环境的问题，同一份代码简单切换Targets轻松搞定。","tags":[]},{"title":"iOS app各种图片尺寸（Icon,Launchimg,应用市场） ","date":"2017-02-04T07:20:24.000Z","path":"2017/02/04/iOS-app各种图片尺寸（Icon-Launchimg-应用市场）/","text":"启动图尺寸（与应用市场图片尺寸相同） 320*480 640*960 640*1136 750*1334 2208*1242 2.Icon尺寸 图片命名 尺寸 Icon-Small@3x.png 87*87 Icon-40@3x.png 120*120 Icon-60@3x.png 180*180 Icon.png 57*57 Icon@2x.png 114*114 Icon-Small.png 29*29 Icon-Small@2x.png 58*58 Icon-Small-50.png 50*50 Icon-Small-50@2x.png 100*100 Icon-72.png 72*72 Icon-72@2x.png 144*144 Icon-40.png 40*40 Icon-40@2x.png 80*80 Icon-60.png 60*60 Icon-60@2x.png 120*120 Icon-76.png 76*76 Icon-76@2x.png 152*152 推荐工具：Asset Catalog Creator Free 使用该工具只需一张1024*1024的Icon就可以自动生成以上各种尺寸的Icon,包括图片命名，非常方便，也可以生成各种尺寸启动图，不过该功能是收费的。","tags":[]},{"title":"Objective-C 编码规范(一)","date":"2017-02-04T07:01:00.000Z","path":"2017/02/04/Objective-C 编码规范(一)/","text":"目录 1 留白和格式 1.1 空格 VS 制表符 1.2 花括号 1.3 列数 1.4 方法的声明和定义 1.5 方法调用 1.6 协议名 1.7 块（闭包） 1.8 枚举类型 1.9 Case语句 参考 1 留白和格式1.1 空格 VS 制表符 【建议】使用空格进行缩进。 不要在工程里使用Tab键，使用空格来进行缩进。通过设置 Xcode &gt; Preferences &gt; Text Editing 将Tab和自动缩进都设置为4个空格。 类方法声明在方法类型与返回类型之间要有空格。 1234 // 糟糕-(void)methodName:(NSString *)string; // OK - (void)methodName:(NSString *)string; 条件判断的括号内侧不应有空格。 12345678// 糟糕if ( a &lt; b ) &#123; // something&#125; // OKif (a &lt; b) &#123; // something&#125; 关系运算符（如 &gt;= 、 != ）和逻辑运算符（如 &amp;&amp; 、 || ）两边要有空格。 1234 // OK(someValue &gt; 100)? YES : NO // OK(items)?: @[] 二元算数运算符两侧是否加空格不确定，根据情况自己定。一元运算符与操作数之前没有空格。多个参数逗号后留一个空格（这也符合正常的西文语法）。 1.2 花括号 【建议】方法大括号和其他大括号(if/else/switch/while 等.)总是在同一行语句打开但在新行中关闭。 123456if (user.isHappy) &#123; //Do something&#125; else &#123; //Do something else&#125; 1.3 列数 【建议】尽量让你的代码保持在 80 列之内。 通过设置 Xcode &gt; Preferences &gt; Text Editing &gt; Show page guide，来使越界更容易被发现。 1.4 方法的声明和定义 【建议】 +/- 和返回类型之间须使用一个空格，参数列表中只有参数之间可以有空格。 例： 1234567+ (NSDate *)dateFromString:(NSString *)string&#123; NSDateFormatter *formatter = [[NSDateFormatter alloc]init]; [formatter setDateFormat:@&quot;yyyy-MM-dd HH:mm:ss&quot;]; NSDate *date = [formatter dateFromString:string]; [formatter release]; return date;&#125; 星号前的空格是可选的。当写新的代码时，要与先前代码保持一致。如果一行有非常多的参数，更好的方式是将每个参数单独拆成一行。如果使用多行，将每个参数前的冒号对齐。12345- (void)doSomethingWith:(GTMFoo *)theFoo rect:(NSRect)theRect interval:(float)theInterval &#123; ...&#125; 当第一个关键字比其它的短时，保证下一行至少有 4 个空格的缩进。这样可以使关键字垂直对齐，而不是使用冒号对齐：12345- (void)short:(GTMFoo *)theFoo longKeyword:(NSRect)theRect evenLongerKeyword:(float)theInterval &#123; ...&#125; 1.5 方法调用 【建议】方法调用应尽量保持与方法声明的格式一致。当格式的风格有多种选择时，新的代码要与已有代码保持一致。 调用时所有参数应该在同一行：1[myObject doFooWith:arg1 name:arg2 error:arg3]; 或者每行一个参数，以冒号对齐：123[myObject doFooWith:arg1 name:arg2 error:arg3]; 方法定义与方法声明一样，当关键字的长度不足以以冒号对齐时，下一行都要以四个空格进行缩进。123[myObj short:arg1 longKeyword:arg2 evenLongerKeyword:arg3]; 1.6 协议名 【建议】类型标识符和尖括号内的协议名之间，不能有任何空格。 这条规则适用于类声明、实例变量以及方法声明。例如： 123456@interface MyProtocoledClass : NSObject&lt;NSWindowDelegate&gt; &#123; @private id&lt;MyFancyDelegate&gt; delegate_;&#125;- (void)setDelegate:(id&lt;MyFancyDelegate&gt;)aDelegate;@end @public 和 @private 访问修饰符应该以一个空格缩进。 1.7 块（闭包） 【建议】块（block）适合用在 target/selector 模式下创建回调方法时，因为它使代码更易读。块中的代码应该缩进 4 个空格。 取决于块的长度，下列都是合理的风格准则： 如果一行可以写完块，则没必要换行。 如果不得不换行，关括号应与块声明的第一个字符对齐。 块内的代码须按 4 空格缩进。 如果块太长，比如超过 20 行，建议把它定义成一个局部变量，然后再使用该变量。 如果块不带参数，^{ 之间无须空格。如果带有参数，^( 之间无须空格，但 ) { 之间须有一个空格。 块内允许按两个空格缩进，但前提是和项目的其它代码保持一致的缩进风格。 123456789101112131415161718192021222324252627282930313233343536373839404142// The entire block fits on one line.[operation setCompletionBlock:^&#123; [self onOperationDone]; &#125;];[operation setCompletionBlock:^&#123; [self.delegate newDataAvailable];&#125;];dispatch_async(fileIOQueue_, ^&#123; NSString* path = [self sessionFilePath]; if (path) &#123; // ... &#125;&#125;);[[SessionService sharedService] loadWindowWithCompletionBlock:^(SessionWindow *window) &#123; if (window) &#123; [self windowDidLoad:window]; &#125; else &#123; [self errorLoadingWindow]; &#125; &#125;];// An example where the parameter wraps and the block declaration does// not fit on the same line as the name.[[SessionService sharedService] loadWindowWithCompletionBlock: ^(SessionWindow *window) &#123; if (window) &#123; [self windowDidLoad:window]; &#125; else &#123; [self errorLoadingWindow]; &#125; &#125;];// Large blocks can be declared out-of-line.void (^largeBlock)(void) = ^&#123; // ...&#125;;[operationQueue_ addOperationWithBlock:largeBlock]; 1.8 枚举类型 【建议】当使用enum时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在SDK有一个宏NS_ENUM()来帮助和鼓励你使用固定的基本类型。12345typedef NS_ENUM(NSInteger, RWTLeftMenuTopItemType) &#123; RWTLeftMenuTopItemMain, RWTLeftMenuTopItemShows, RWTLeftMenuTopItemSchedule&#125;; 1.9 Case语句 【建议】大括号在case语句中并不是必须的，除非编译器强制要求。当一个case语句包含多行代码时，大括号应该加上。 12345678910111213141516switch (condition) &#123; case 1: // ... break; case 2: &#123; // ... // Multi-line example using braces break; &#125; case 3: // ... break; default: // ... break;&#125; 有很多次，当相同代码被多个cases使用时，一个fall-through应该被使用。一个fall-through就是在case最后移除’break’语句，这样就能够允许执行流程跳转到下一个case值。为了代码更加清晰，一个fall-through需要注释一下。 12345678910switch (condition) &#123; case 1: // ** fall-through! ** case 2: // code executed for values 1 and 2 break; default: // ... break;&#125; 当在switch使用枚举类型时，’default’是不需要的。例如：123456789101112RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;switch (menuType) &#123; case RWTLeftMenuTopItemMain: // ... break; case RWTLeftMenuTopItemShows: // ... break; case RWTLeftMenuTopItemSchedule: // ... break;&#125;","tags":[]},{"title":"Objective-C 编码规范(二)","date":"2017-02-04T06:51:00.000Z","path":"2017/02/04/Objective-C编码规范（二/","text":"目录 2 命名 2.1 文件名 2.2 Objective-C++ 2.3 类名 2.4 类别名 2.5 Objective-C方法名 2.6 变量名 2.7 通知名 2.8 协议名 对于易维护的代码而言，命名规则非常重要。Objective-C 的方法名往往十分长，但代码块读起来就像散文一样，不需要太多的代码注释。当编写纯粹的 Objective-C 代码时，我们基本遵守标准的 Objective-C naming rules，这些命名规则可能与 C++ 风格指南中的大相径庭。例如，Google 的 C++ 风格指南中推荐使用下划线分隔的单词作为变量名，而(苹果的)风格指南则使用驼峰命名法，这在 Objective-C 社区中非常普遍。任何的类、类别、方法以及变量的名字中都使用全大写的 首字母缩写。这遵守了苹果的标准命名方式，如 URL、TIFF 以及 EXIF。当编写 Objective-C++ 代码时，事情就不这么简单了。许多项目需要实现跨平台的 C++ API，并混合一些 Objective-C、Cocoa 代码，或者直接以 C++ 为后端，前端用本地 Cocoa 代码。这就导致了两种命名方式直接不统一。 我们的解决方案是：编码风格取决于方法/函数以哪种语言实现。如果在一个 @implementation 语句中，就使用 Objective-C 的风格。如果实现一个 C++ 的类，就使用 C++ 的风格。这样避免了一个函数里面实例变量和局部变量命名规则混乱，严重影响可读性。 2 命名 2.1 文件名 【建议】文件名的命名应反映出其实现了什么类–包括大小写。遵循你所参与项目的约定。 文件的扩展名应该如下：|后缀|文件类型说明||:—————|:—————–|| .h | C/C++/Objective-C头文件 || .m |Objective-C实现文件 || .mm | Ojbective-C++ 的实现文件 ||.cc |纯C++实现文件 ||.c |纯C实现文件 | 2.2 Objective-C++ 【建议】源代码文件内，Ojbective-C++ 代码遵循你正在实现的函数/方法的风格。 为了最小化 Cocoa/Objective-C 与 C++ 之间命名风格的冲突，根据待实现的函数/方法选择编码风格。实现 @implementation 语句块时，使用 Objective-C 的命名规则；如果实现一个 C++ 的类，就使用 C++ 命名规则。 123456789101112131415161718192021222324252627282930313233343536// file: cross_platform_header.h class CrossPlatformAPI &#123; public: ... int DoSomethingPlatformSpecific(); // impl on each platform private: int an_instance_var_; &#125;;// file: mac_implementation.mm #include &quot;cross_platform_header.h&quot; // A typical Objective-C class, using Objective-C naming. @interface MyDelegate : NSObject &#123; @private int instanceVar_; CrossPlatformAPI* backEndObject_; &#125; (void)respondToSomething:(id)something; @end @implementation MyDelegate - (void)respondToSomething:(id)something &#123; // bridge from Cocoa through our C++ backend instanceVar_ = backEndObject-&gt;DoSomethingPlatformSpecific(); NSString* tempString = [NSString stringWithInt:instanceVar_]; NSLog(@&quot;%@&quot;, tempString); &#125;@end // The platform-specific implementation of the C++ class, using // C++ naming.int CrossPlatformAPI::DoSomethingPlatformSpecific() &#123; NSString* temp_string = [NSString stringWithInt:an_instance_var_]; NSLog(@&quot;%@&quot;, temp_string); return [temp_string intValue]; &#125; 2.3 类名 【建议】类名（以及类别、协议名）应首字母大写，并以驼峰格式分割单词。 应用层 的代码，应该尽量避免不必要的前缀。为每个类都添加相同的前缀无助于可读性。当编写的代码期望在不同应用程序间复用时，应使用前缀（如：GTMSendMessage）。 2.4 类别名 【建议】类别名应该包含它所扩展的类的名字。同时还应该表明该类别的功能。推荐如下方式：” UILabel+FlickerNumber.h” ###2.5 Objective-C方法名 【建议】方法名应该以小写字母开头，并混合驼峰格式。每个具名参数也应该以小写字母开头。 方法名应尽量读起来就像句子，这表示你应该选择与方法名连在一起读起来通顺的参数名。（例如，convertPoint:fromRect: 或 replaceCharactersInRange:withString:）。 访问器方法应该与他们 要获取的 成员变量的名字一样，但不应该以get作为前缀。 以 get 、 set 开头的方法有特殊的意义，不要随意定义。set 是属性默认的设置方法，如果函数不是为了设置类成员，则不要用 set 开头，可用 setup 替代。 get 和属性方法无关，但在 Cocoa 中，其标准行为是通过引用传值，而不是直接返回结果的。欲获取变量，直接以变量名为名，如： userInfomation ，而不是 getUserInfomation 。例如： 12- (id)getDelegate; // AVOID - (id)delegate; // GOOD 这仅限于 Objective-C 的方法名。C++ 的方法与函数的命名规则应该遵从 C++ 风格指南中的规则。 2.6 变量名 【建议】变量名应该以小写字母开头，并使用驼峰格式。类的成员变量应该以下划线作为后缀。 例如：myLocalVariable、myInstanceVariable_。如果不能使用 Objective-C 2.0 的 @property，使用 KVO/KVC 绑定的成员变量可以以一个下划线作为前缀。 2.6.1 普通变量名对于静态的属性（int 或指针），不要使用匈牙利命名法。尽量为变量起一个描述性的名字。不要担心浪费列宽，因为让新的代码阅读者立即理解你的代码更重要。例如： 2.6.2 实例变量实例变量应该混合大小写，并以下划线作为后缀，如 usernameTextField_。然而，如果不能使用 Objective-C 2.0（操作系统版本的限制），并且使用了 KVO/KVC 绑定成员变量时，我们允许例外。这种情况下，可以以一个下划线作为成员变量名字的前缀，这是苹果所接受的键/值命名惯例。如果可以使用 Objective-C 2.0，@property 以及 @synthesize 提供了遵从这一命名规则的解决方案。 2.6.3 常量常量名（如宏定义、枚举、静态局部变量等）应该以小写字母 k 开头，使用驼峰格式分隔单词，如：kInvalidHandle，kWritePerm。 2.7 通知命名 【建议】基本命名格式是： [与通知相关的类名] + [Did | Will] + [UniquePartOfName] + Notification 例如：1234NSApplicationDidBecomeActiveNotificationNSWindowDidMiniaturizeNotificationNSTextViewDidChangeSelectionNotificationNSColorPanelColorDidChangeNotification 2.8协议名 【建议】常用的 delegate、dateSource 做结尾外，还可以使用 …ing 这种形式，如：NSCoding、NSCopying、NSLocking","tags":[]},{"title":"Objective-C 编码规范（三，四）","date":"2017-02-04T06:18:00.000Z","path":"2017/02/04/Objective-C 编码规范（三，四)/","text":"目录 3 注释 3.1 声明部分的注释 3.2 实现部分的注释 3.3 对象所有权 3.4 方法声明注释 3.5 属性的注释 4 代码组织 4.1 条件语句 4.2 实现文件目录结构 3 注释 3.1 声明部分的注释 【建议】每个接口、类别以及协议应辅以注释，以描述它的目的及与整个项目的关系。 123456// A delegate for NSApplication to handle notifications about app // launch and shutdown. Owned by the main app controller. @interface MyAppDelegate : NSObject &#123; ... &#125; @end 如果你已经在文件头部详细描述了接口，可以直接说明 “完整的描述请参见文件头部”，但是一定要有这部分注释。另外，公共接口的每个方法，都应该有注释来解释它的作用、参数、返回值以及其它影响。 为类的线程安全性作注释，如果有的话。如果类的实例可以被多个线程访问，记得注释多线程条件下的使用规则。 3.2 实现部分的注释 【建议】使用 | 来引用注释中的变量名及符号名而不是使用引号。 这会避免二义性，尤其是当符号是一个常用词汇，这使用语句读起来很糟糕。例如，对于符号 count ：1// Sometimes we need |count| to be less than zero. 或者当引用已经包含引号的符号：1// Remember to call |StringWithoutSpaces(&quot;foo bar baz&quot;)| 注：不过中文注释的话可以忽略该条 3.3 对象所有权 【建议】当与 Objective-C 最常规的作法不同时，尽量使指针的所有权模型尽量明确。 继承自 NSObject 的对象的实例变量指针，通常被假定是强引用关系（retained），某些情况下也可以注释为弱引用（weak）或使用 __weak 生命周期限定符。同样，声明的属性如果没有被类 retained，必须指定是弱引用或赋予 @property 属性。然而，Mac 软件中标记上 IBOutlets 的实例变量，被认为是不会被类 retained 的。 当实例变量指向 CoreFoundation、C++ 或者其它非 Objective-C 对象时，不论指针是否会被 retained，都需要使用 __strong 和 __weak 类型修饰符明确指明。CoreFoundation 和其它非 Objective-C 对象指针需要显式的内存管理，即便使用了自动引用计数或垃圾回收机制。当不允许使用 __weak 类型修饰符（比如，使用 clang 编译时的 C++ 成员变量），应使用注释替代说明。 12345678910111213@interface MyDelegate : NSObject &#123; @private IBOutlet NSButton *okButton_; // normal NSControl; implicitly weak on Mac only AnObjcObject* doohickey_; // my doohickey __weak MyObjcParent *parent_; // so we can send msgs back (owns me) // non-NSObject pointers... __strong CWackyCPPClass *wacky_; // some cross-platform object __strong CFDictionaryRef *dict_; &#125; @property(strong, nonatomic) NSString *doohickey; @property(weak, nonatomic) NSString *parent; @end 3.4 方法声明注释 【建议】声明的方法，要注释方法功能，参数意义，返回值，格式如下： 1234567891011121314151617181920//含参数，有返回值的方法注释/** * 初始化方法-2 * @param frame frame * @param array 标题数组 * @param index 默认选中标题索引 * @return WJSegmentView */- (instancetype)initWithFrame:(CGRect)frame titleArray:(NSArray *)array sellectIndex:(long)index; //无参，无返回值方法注释/**移除键盘*/+ (void)removeKeyBoard&#123; NSArray *windows = [[UIApplication sharedApplication] windows]; for(UIWindow *window in windows)&#123; [CommonMethods textViewTextFieldResignFirstResponder:window]; &#125;&#125; 3.5 属性的注释 【建议】在声明文件中声明的实例变量在上一行加注释。或者直接在实例变量后边注释，与项目已有风格保持一致。格式如下： 12345678910111213@property (nonatomic,copy)NSString *loginID;//登录ID@property (nonatomic,copy)NSString *userName;//用户名@property (nonatomic,copy)NSString *realName;//真是姓名 @property (nonatomic,copy)NSString *shareUrl;//二维码分享链接 @property (nonatomic,copy)NSString *appShareUrl;//社交分享链接 @property (nonatomic,copy)NSString *headPortraitAddr;//用户头像/**标题数组*/@property (nonatomic,retain)NSArray *titleArray;/**选中按钮底部背景*/@property (nonatomic,retain)UIView *backgroundView;/**默认选中索引*/ @property (nonatomic,assign)long selectIndex; 4 代码组织4.1 条件语句当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套if语句，多个返回语句也是OK。 123456- (void)someMethod &#123; if (![someOther boolValue]) &#123; return; &#125; //Do something important &#125; 【建议】出现超过两层循环的代码，用函数或block替代// 为了简化示例，没有错误处理，并使用了伪代码 123456789101112131415161718192021// 糟糕的例子- (Task *)creatTaskWithPath:(NSString *)path &#123; Task *aTask; if ([path isURL]) &#123; if ([fileManager isWritableFileAtPath:path]) &#123; if (![taskManager hasTaskWithPath:path]) &#123; aTask = [[Task alloc] initWithPath:path]; &#125; else &#123; return nil; &#125; &#125; else &#123; return nil; &#125; &#125; else &#123; return nil; &#125; return aTask;&#125; 1234567891011121314151617// 改写的例子- (Task *)creatTaskWithPath:(NSString *)path &#123; if (![path isURL]) &#123; return nil; &#125; if (![fileManager isWritableFileAtPath:path]) &#123; return nil; &#125; if ([taskManager hasTaskWithPath:path]) &#123; return nil; &#125; Task *aTask = [[Task alloc] initWithPath:path]; return aTask;&#125; 4.2 实现文件目录结构 【建议】 在函数分组和protocol/delegate实现中使用#pragma mark -来分类方法，要遵循以下一般结构： 12345678910111213141516171819202122232425262728293031323334353637#pragma mark - Lifecycle- (instancetype)init &#123;&#125;- (void)dealloc &#123;&#125;- (void)viewDidLoad &#123;&#125;- (void)viewWillAppear:(BOOL)animated &#123;&#125;- (void)didReceiveMemoryWarning &#123;&#125;#pragma mark - Custom Accessors- (void)setCustomProperty:(id)value &#123;&#125;- (id)customProperty &#123;&#125;#pragma mark - IBActions- (IBAction)submitData:(id)sender &#123;&#125;#pragma mark - Public- (void)publicMethod &#123;&#125;#pragma mark - Private- (void)privateMethod &#123;&#125;#pragma mark - Protocol conformance#pragma mark - UITextFieldDelegate#pragma mark - UITableViewDataSource#pragma mark - UITableViewDelegate#pragma mark - NSCopying- (id)copyWithZone:(NSZone *)zone &#123;&#125;#pragma mark - NSObject- (NSString *)description &#123;&#125;","tags":[]},{"title":"部署Hexo博客填坑记","date":"2017-01-23T07:07:00.000Z","path":"2017/01/23/部署Hexo博客填坑记/","text":"部署Hexo博客新家小记最近项目不忙，于是花了点时间部署了Hexo,虽然不难，但是还是遇到点小问题，特此写下这篇博客，希望能帮到有需要的同学。 hexo 安装步骤：12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 遗憾的是第一步就卡住了，安装过程贼慢，我是等了一个小时，还没有安装完成，简直忍无可忍，查阅相关资料，原来是被墙的问题。 解决方案：选择国内镜像去获取资源 在安装时可以手动指定从哪个镜像服务器获取资源，我们可以使用阿里巴巴在国内的镜像服务器，命令如下： 1npm install hexo-cli -g --registry=http://registry.npm.taobao.org 只需要使用–registry参数指定镜像服务器地址，为了避免每次安装都需要–registry参数，可以使用如下命令进行永久设置： 1npm config set registry http://registry.npm.taobao.org 换了国内镜像，安装速度就很快了,原来一个小时没装成功的，现在不到一分钟就解决了，就是这么任性。 获取资源没问题了，可能还会遇到另一个问题：权限问题 很明显可以看到 “permission denied“ 解决方案：sudo npm install hexo-cli -g","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"部署Hexo博客新家小记","date":"2017-01-23T07:07:00.000Z","path":"2017/01/23/测试/","text":"部署Hexo博客新家小记最近项目不忙，于是花了点时间部署了Hexo,虽然不难，但是还是遇到点小问题，特此写下这篇博客，希望能帮到有需要的同学。 hexo 安装步骤：12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 遗憾的是第一步就卡住了，安装过程贼慢，我是等了一个小时，还没有安装完成，简直忍无可忍，查阅相关资料，原来是被墙的问题。 解决方案：选择国内镜像去获取资源 在安装时可以手动指定从哪个镜像服务器获取资源，我们可以使用阿里巴巴在国内的镜像服务器，命令如下： npm install hexo-cli -g –registry=http://registry.npm.taobao.org 只需要使用–registry参数指定镜像服务器地址，为了避免每次安装都需要–registry参数，可以使用如下命令进行永久设置： npm config set registry http://registry.npm.taobao.org 换了国内镜像，安装速度就很快了,原来一个小时没装成功的，现在不到一分钟就解决了，就是这么任性。 获取资源没问题了，可能还会遇到另一个问题：权限问题 很明显可以看到 “permission denied“ 解决方案：sudo npm install hexo-cli -g","tags":[]},{"title":"金融类app数值精确计算问题","date":"2017-01-23T03:54:55.000Z","path":"2017/01/23/金融类app数值精确计算问题/","text":"金融类app各种数值的精确计算问题最近总算闲下来了，有时间把前段时间app里边踩到的坑总结下，既金融类app中有关数值精确计算的问题。 1.简单粗暴的方法—doubleValue解决刚开始接手的项目中关于数值的计算就是按照字符串直接转doubleValue的方式转化为后进行加减乘除运算。这样做在大多数情况下是不会有问题的，但如果经过全面测试的话，有些字符串转double会出现精度损失问题，计算结果也会出现不准确的问题，一个最近踩过的坑就是用户再输入投资金额的时候会对自己账户中的可用余额进行判断，以确定余额是否充足，测试的时候输入很多数据都没问题，但线上用户大量数据就会出现偶尔数据错误，用户输入金额明明和可用余额一样，但判断的时候就会提示可用余额不足，老板使用过程中也遇到过，还找了我好几次，汗，都是之前开发人员的坑。所以记住这丫简单粗暴的方法针对金融类的对数据精度及其敏感的项目不可取。 2.明智之举—NSDecimalNumber NSDecimalNumber是苹果提供的专门金融货币精确数值计算的API。 1234567+ (instancetype)decimalNumberHandlerWithRoundingMode:(NSRoundingMode)roundingMode scale:(short)scale raiseOnExactness:(BOOL)raiseOnExactness raiseOnOverflow:(BOOL)raiseOnOverflow raiseOnUnderflow:(BOOL)raiseOnUnderflow raiseOnDivideByZero:(BOOL)raiseOnDivideByZero 参数 说明 roundingMode 要使用的舍入模式，有四种值： NSRoundUp, NSRoundDown, NSRoundPlain, and NSRoundBankers scale 结果保留几位小数 raiseOnExactness 发生精确错误时是否抛出异常，一般为NO raiseOnOverflow 发生溢出错误时是否抛出异常，一般为NO raiseOnUnderflow 发生不足错误时是否抛出异常，一般为NO raiseOnDivideByZero 被0除时是否抛出异常，一般为YES 2.1 NSDecimalNumber 的使用。 NSDecimalNumber是进行数值计算的对象，ji所有的加减乘除，幂运算操作对象。 12345678910111213141516171819202122232425NSDecimalNumberHandler *handler = [NSDecimalNumberHandler decimalNumberHandlerWithRoundingMode:NSRoundBankers scale:2 raiseOnExactness:NO raiseOnOverflow:NO raiseOnUnderflow:NO raiseOnDivideByZero:YES];NSDecimalNumber *num1 = [NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%@&quot;,@&quot;2.37&quot;]];NSDecimalNumber *num2 = [NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%@&quot;,@&quot;15.89&quot;]];//加NSDecimalNumber *addResult = [num1 decimalNumberByAdding:num2 withBehavior:handler];//减NSDecimalNumber *subtractResult = [num1 decimalNumberBySubtracting:num2 withBehavior:handler];//乘NSDecimalNumber *multiplyResult = [num1 decimalNumberByMultiplyingBy:num2 withBehavior:handler];//除NSDecimalNumber *divideResult = [num1 decimalNumberByDividingBy:num2 withBehavior:handler];//平方NSDecimalNumber *powerResult = [num1 decimalNumberByRaisingToPower:2 withBehavior:handler];NSLog(@&quot;\\n%f\\n%f\\n%f\\n%f\\n%f&quot;,[addResult doubleValue],[subtractResult doubleValue],[multiplyResult doubleValue],[divideResult doubleValue],[powerResult doubleValue]); 这样就能够很好地解决金融类app货币单位精确计算的问题。但有一点需要注意的是如果计算公式比较长，那么withBehavior应该在最后一步使用，切不可在计算过程中进行舍入操作，相信有点数学常识的同学都能明白这个问题。如下：等额本息的预计收益计算 * 公式： 每月本息还款额=(投资金额月利率(1+月利率)^还款月数)/(((1+月利率)^还款月数)-1) 1234567891011121314151617181920212223242526272829303132333435/** * 等额本息标的收益计算 * 公式： 每月本息还款额=(投资金额*月利率*(1+月利率)^还款月数)/(((1+月利率)^还款月数)-1) * @param interest 年化收益 * @param investAmount 投资金额 * @param selectBid 选择的标 * * @return 收益 */+ (double)calculatePrincipalAndInterestBidWithInvestInterest:(double)interest amount:(NSString *)investAmount bid:(Bid *)selectBid&#123; NSDecimalNumberHandler *roundBanker = [NSDecimalNumberHandler decimalNumberHandlerWithRoundingMode:NSRoundBankers scale:2.0f raiseOnExactness:NO raiseOnOverflow:NO raiseOnUnderflow:NO raiseOnDivideByZero:YES]; NSDecimalNumber *investAmountDec = [[NSDecimalNumber alloc] initWithString:investAmount];//投资金额 NSDecimalNumber *monthInterestDec = [[NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%f&quot;,interest/100]] decimalNumberByDividingBy:[NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%f&quot;,12.00]]];//月利率 double month = selectBid.creditPeriod;//标的募集期数 if (selectBid.creditType == CreditType_DaylyOneOffPayment) &#123; //按天标,转化为月份 month = month/30.00; &#125; NSDecimalNumber *monthDec = [NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%f&quot;,month]];//还款月数// * 公式： 每月本息还款额=(投资金额*月利率*(1+月利率)^还款月数)/(((1+月利率)^还款月数)-1) NSDecimalNumber *decNum1 = [[[[[NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%d&quot;,1]] decimalNumberByAdding:monthInterestDec] decimalNumberByRaisingToPower:month] decimalNumberByMultiplyingBy:monthInterestDec] decimalNumberByMultiplyingBy:investAmountDec]; NSDecimalNumber *decNum2 = [[[[NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%d&quot;,1]] decimalNumberByAdding:monthInterestDec] decimalNumberByRaisingToPower:month] decimalNumberBySubtracting:[NSDecimalNumber decimalNumberWithString:[NSString stringWithFormat:@&quot;%d&quot;,1]]]; NSDecimalNumber *monthIncomeDec = [decNum1 decimalNumberByDividingBy:decNum2];//月本息还款额 NSDecimalNumber *totalIncomeDec = [[monthDec decimalNumberByMultiplyingBy:monthIncomeDec] decimalNumberBySubtracting:investAmountDec withBehavior:roundBanker];//总还款额 - 本金 = 总收益 return [totalIncomeDec doubleValue] &gt; 0 ? [totalIncomeDec doubleValue] : 0;&#125;","tags":[]},{"title":"iOS 项目自动化打包实践","date":"2017-01-23T02:56:00.000Z","path":"2017/01/23/iOS-项目自动化打包实践/","text":"iOS 项目自动化打包实践1.准备工作1.1 安装fir.cli具体安装步骤见github. 1.2 Xcode 证书配置Xcode 根据不同的模式配置不同的证书，默认有Release，Debug,可自行添加，添加方法见图。 AdHoc 就是新添加的用于测试分发 的打包方式。配置AdHoc证书 Debug 调试模式，配置调试证书 Release 发布模式，配置发布证书 配置好后就以后正常情况下，真机调试，发布appstore打包，测试分发打包都不用再改这些证书配置了。 1.3 fir.im 账号申请2. 项目环境2.1 cocoapods 管理依赖.2.2多target项目 (参考链接)3. 实现目标1.实现一键自动化打包，上传第三方托管平台。 2.可自由配置打包本地项目还是远程git仓库项目 3.自由配置打包Target,更新日志，打包类型，打包分支 4.应用使用脚本打包需要配置工程的参数，脚本中有详细的注释，打包时只需修改scheme,branch,changeLog，之后把脚本文件拖拽到终端执行即可。 把fir.im上的app短连接地址复制出来，发给测试人员收藏该地址，以后打包成功，测试人员直接刷新网页就ok，该地址会显示app的最新安装二维码。 遇到问题：1.执行脚本如遇权限问题，执行 chmod 755 $SCRIPT_PATH2.目前遇到远程git仓库打包无法区分scheme的问题(暂未解决) 附录：自动打包脚本","tags":[{"name":"iOS,自动化打包,fir.cli","slug":"iOS-自动化打包-fir-cli","permalink":"http://yoursite.com/tags/iOS-自动化打包-fir-cli/"}]},{"title":"Hello World","date":"2017-01-22T09:12:00.000Z","path":"2017/01/22/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]